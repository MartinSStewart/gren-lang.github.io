{"is404":false,"staticData":{"774672150":"{\"parsedFrontmatter\":{\"title\":\"Why Gren?\",\"description\":\"Why should you learn Gren? What benefits does it bring to the table?\"},\"withoutFrontmatter\":\"\\nGren is a programming language that helps you write simple and correct software.\\n\\nWhat does that mean?\\n\\n#### Simple\\n\\nGren measures simplicity by how many outcomes an operation can have. Take the following code as an example:\\n\\n```js\\na + b\\n```\\n\\nIn some languages, this can mean a lot of different things. Some languages allow you to override the definition of `+`, which means it might execute an arbitrary function. For some languages, this statement can either append one string to another, or add two numbers together. Some languages might even try to convert `a` and `b` to be the same type, before executing the `+` operation.\\n\\nIn Gren, the above statement can only mean one thing: `a` and `b` are numbers, and the result is that of mathematical addition.\\n\\nThe fact that this statement can only mean one thing is what makes it simple. When reading the code you can be very certain what the result of this operation is, as long as it compiles.\\n\\nLet's consider one more example, this one in JavaScript:\\n\\n```js\\nfunction doubleA(obj) {\\n    var a1 = obj.a;\\n\\n    verify(obj);\\n    var a2 = obj.a;\\n    \\n    return a1 + a2;\\n}\\n```\\n\\nTry to answer these questions:\\n\\n1. How many function calls do you see?\\n2. Is the value of `obj` changed by any statement in this function?\\n3. Does `a1` equal `a2`?\\n4. What type does this function return?\\n5. Will this function return?\\n\\nIt might surprise you that, without knowing more of the surrounding context, you can't really answer any of these questions.\\n\\n1. JavaScript has a language feature called _getters_. This means that a statement like `obj.a` might actually call a function to compute a value. Without knowing how `obj` is defined, there's no way of knowing how many functions will be called.\\n2. JavaScript allows mutation. The potential function call `obj.a`, and the actual function call `verify(obj)` might end up changing the `obj` value. You need to know how `obj` and `verify` is defined to be certain.\\n3. Since `obj` can change, there's no way to know without knowing how `obj` and `verify` is defined. In languages that support threads, you also need to know if `obj` is accessible in any other thread.\\n4. `+` works on both numbers and strings. So it probably returns either a number or a string.\\n5. Maybe. Any function call can throw an exception.\\n\\nLet's pretend the above code was written in Gren, could we answer the same questions with certainty then?\\n\\n1. Gren doesn't have getters, so the answer is 2 (`verify` and `+`).\\n2. Gren doesn't have mutation, so the answer is no.\\n3. Yes, because of (2).\\n4. A number, since `+` only works on numbers.\\n5. Gren doesn't support exceptions, so the answer is yes, if we ignore the possibility of infinite loops and running out of memory.\\n\\nThe simplicity of Gren makes it easier to reason about code. Even when the code in question was written by someone else. The value of simplicity grows along with the size of your code base.\\n\\n#### Correct\\n\\nThere are certain constructs that Gren doesn't have, that are often the source of bugs in other languages. These things are:\\n\\n1. Null\\n2. Exceptions\\n3. Uncontrolled side-effects\\n\\nWhat Gren _does have_ is a flexible, although strict, type system which allows you represent these constructs in a way that let's the compiler help you avoid the most common bugs.\\n\\nInstead of `null`, Gren let's you express the absense of a value by using what is known as a custom type:\\n\\n```gren\\ntype Maybe a\\n  = Just a\\n  | Nothing\\n```\\n\\nThis type represents a value which may, or may not, exist. Whenever you try to use this value, the compiler will force you to check if you have a `Just` or `Nothing`.\\n\\nThe same principle applies to exceptions. Representing an operation which may cause an error is represented by the type:\\n\\n```gren\\ntype Result err ok\\n  = Ok ok\\n  | Err err\\n```\\n\\nIf a function returns a `Result` value, the compiler will force you to handle both the success and the failure condition.\\n\\nConsider for a moment what this means. Since Gren is statically typed, that means that whenever you see a function which _doesn't_ return a `Maybe` or a `Result` type, you can be certain that you'll always end up with the promised return value.\\n\\nThe same concept applies to side-effects like performing HTTP calls or saving things to disk. A side effect has to be modelled by the type system, and this also means that you have greater insights into the sort of things a third-party package can do.\\n\\n#### Conclusion\\n\\nGren has made a very specific set of trade offs that makes it easy to locate and isolate bugs and side effects. These same trade offs also make the language small in both syntax and concepts. This again reduces the necessary time investment to learn the language, and makes it easy for the compiler to provide detailed and helpful error messages.\\n\\nThese benefits comes at the cost of brevity. There's a chance that other programming languages will allow you to write less code.\\n\\nIt is our belief that as your program grows in complexity and scope, the trade offs made by Gren make more and more sense.\\n\"}","847994132":"[\"guide/01_why_gren.md\",\"guide/02_hello_world.md\",\"guide/03_basic_syntax.md\",\"guide/90_faq.md\"]","3581369079":"{\"parsedFrontmatter\":{\"title\":\"Hello, world!\",\"description\":\"Learn how to setup the easiest project known to man: \\\"Hello, world!\\\"\"},\"withoutFrontmatter\":\"\\nGetting a simple program to compile is a good way to verify that you've got everything setup correctly. Let's try to write a Gren program that outputs \\\"Hello, world!\\\" when opened up in browser.\\n\\nIf you haven't already, make sure you've [installed Gren](/install).\\n\\nWhen you've setup the compiler correctly, it's time to initialize our project. We're going to assume that you've got a bash terminal setup.\\n\\n#### Gren.json\\n\\nStart by creating a `hello_world` directory, and `cd` into it.\\n\\nEvery Gren project contains a `gren.json` file. This file contains all the information that the compiler needs to compile your program. You can create such a file by running `gren init`.\\n\\n```sh\\nrobin@bekk-mac-2715 ~/W/g/tmp> gren init\\nHello! Gren projects always start with an gren.json file. I can create them!\\n\\nWould you like me to create an gren.json file now? [Y/n]: \\nUpdating gren-lang/browser... Ok!\\nUpdating gren-lang/core... Ok!\\nUpdating gren-lang/html... Ok!\\nUpdating gren-lang/json... Ok!\\nUpdating gren-lang/time... Ok!\\nUpdating gren-lang/url... Ok!\\nUpdating gren-lang/virtual-dom... Ok!\\nOkay, I created it.\\n```\\n\\nThe compiler will create a `gren.json` file for you that lists a few dependencies required to compile a simple browser based application. These dependencies are then downloaded, which explains the output you see above.\\n\\nThe `gren.json` file should look something like the following:\\n\\n```json\\n{\\n    \\\"type\\\": \\\"application\\\",\\n    \\\"source-directories\\\": [\\n        \\\"src\\\"\\n    ],\\n    \\\"gren-version\\\": \\\"0.1.0\\\",\\n    \\\"dependencies\\\": {\\n        \\\"direct\\\": {\\n            \\\"gren-lang/browser\\\": \\\"1.0.0\\\",\\n            \\\"gren-lang/core\\\": \\\"1.0.0\\\",\\n            \\\"gren-lang/html\\\": \\\"1.0.0\\\"\\n        },\\n        \\\"indirect\\\": {\\n            \\\"gren-lang/json\\\": \\\"1.0.0\\\",\\n            \\\"gren-lang/time\\\": \\\"1.0.0\\\",\\n            \\\"gren-lang/url\\\": \\\"1.0.0\\\",\\n            \\\"gren-lang/virtual-dom\\\": \\\"1.0.0\\\"\\n        }\\n    },\\n    \\\"test-dependencies\\\": {\\n        \\\"direct\\\": {},\\n        \\\"indirect\\\": {}\\n    }\\n}\\n```\\n\\nLet's explain this property by property:\\n\\n* `type`: this tells the compiler that we're attempting to compile a Gren application, as opposed to a package. Packages have slightly different `gren.json` files. You can see an example if you run `gren init --package`.\\n* `source-directories`: This lists every sub-folder that the compiler should look for Gren source files in. This is usually fine as is.\\n* `gren-version`: Which version of the compiler is this application compatible with. If you're using an unsupported compiler, it will not compile.\\n* `dependencies`: Lists the packages required for you application to function. Direct dependencies are those which you application make direct use of, while indirect dependencies are usually required by your direct dependencies.\\n* `test-dependencies`: Unused for now, as Gren hasn't gotten a test framework yet.\\n\\nYour `gren.json` should be good enough for what we're about to do, so let's write some actual code.\\n\\n#### Writing your program\\n\\nCreate a `src/Main.gren` file and fill it with the following content:\\n\\n```gren\\nmodule Main exposing (main)\\n\\nimport Html exposing (Html)\\n\\nmain : Html a\\nmain =\\n  Html.text \\\"Hello, world!\\\"\\n```\\n\\nWe create a new module, called `Main` and expose the `main` constant from it.\\n\\nThen, we import the `Html` module (from the `gren-lang/html` package listed in our dependencies) and expose the `Html` type to our module.\\n\\nOur `main` constant represents a `Html` value, which in this particular case is just the text `Hello, world!`.\\n\\nCompile this using `gren make src/Main.gren`. This will produce a `index.html` file which, when opened, displays `Hello, world!`.\\n\\nNow that you've written your first program, head over to the [language guide](/learn) to learn more about Gren.\\n\"}","3650825791":"{\"parsedFrontmatter\":{\"title\":\"FAQ\",\"description\":\"Frequently Asked Questions\"},\"withoutFrontmatter\":\"\\n#### Why is the language called Gren?\\n\\nGren is a norwegian word, meaning branch. This pays homage to both of Gren's origins: Norway and Elm.\\n\\n#### Why is Gren's logo a bird?\\n\\nThe bird is a robin, which happens to be the name of Gren's founder. The robin is placed within the G, which is meant to symbolize that it is sitting on G(ren), which is the norwegian word for branch.\\n\\n#### What is the relationship between Gren and Elm?\\n\\nGren started as a fork of Elm. This is mostly considered to be an implementation detail, a way to speed up initial development.\\n\\nIt's not a goal of Gren to become a replacement, or stay compatible in any way, with Elm.\\n\\n#### What are the differences between Gren and Elm?\\n\\nAs of Gren 0.1.0, the main differences is that Gren has:\\n\\n* A git-based package manager. It's slower, but has access to any github repo that you have, even private ones.\\n* Extended support for pattern matching on records.\\n* The default sequential data structure is an immutable array, not a linked list.\\n* No tuples.\\n* No automatic constructors for type aliased records.\\n* No GLSL syntax.\\n* No reactor.\\n\"}","3812652642":"{\"parsedFrontmatter\":{\"title\":\"Syntax\",\"description\":\"Learn the syntax of Gren\"},\"withoutFrontmatter\":\"\\n#### Comments\\n\\nLines starting with `--` are ignored by the compiler, and are useful for describing somethings to human readers.\\n\\n```gren\\n-- Nothing to see here\\n```\\n\\nYou can also use `{- -}` to have comments span multiple lines.\\n\\n```gren\\n{- This comment\\nspans\\nmultiple lines\\n-}\\n```\\n\\n#### Constants\\n\\nYou can attach names to values. Named values are called constants, because once defined those names can never refer to another value.\\n\\n```gren\\ntheAnswer = 42\\n\\naQuestion = \\\"What was the question again?\\\"\\n\\nhelpful = False\\n```\\n\\n#### Functions\\n\\nA function returns different values depending on its input. In Gren, a function will always return the same result if provided the same input.\\n\\n```gren\\nsumOf first second =\\n    first + second\\n\\nsumOfFiveAndTwo =\\n    sumOf 5 2\\n```\\n\\nHere, `sumOf` is the name of the function, while `first` and `second` are the inputs to the function. The return value of `sumOf`, is the last computed expression. In this case, the only expression is `first + second`, the result of which becomes the returned value.\\n\\n#### Types\\n\\nGren is a staticly typed language, which means that every constant and function are associated with a type, and the use of these types are checked by the compiler to be correct. If you have a function which is defined to accept to integers, the compiler will complain if you were to pass that function something other than two integers.\\n\\nYou might've noticed that you didn't need to specify types in the examples above. That's because Gren is usually smart enought to figure out the types without your help.\\n\\n```gren\\ntheAnswer : Int\\ntheAnswer = 42\\n\\naQuestion : String\\naQuestion = \\\"What was the question again?\\\"\\n\\nhelpful : Bool\\nhelpful = False\\n\\nsumOf : Int -> Int -> Int\\nsumOf first second =\\n    first + second\\n\\nsumOfFiveAndTwo : Int\\nsumOfFiveAndTwo =\\n    sumOf 5 2\\n```\\n\\n`:` can be read as `has type`. One way to read the first constant definition in the above example is `theAnswer has type Int. theAnswer equals 42.`\\n\\nFor functions it get's a little bit more complicated. `->` can be read as `to`. So `sumOf has type Int to Int to Int. sumOf first and second equals first + second.`\\n\\nWhen reading the type signature of a function, the last `->` points to the return value of the function, while the types before represent the inputs.\\n\\n#### Arrays\\n\\nYou can group several values in an array.\\n\\n```gren\\nnumbers : Array Int\\nnumbers =\\n    [ 1, 2, 3, 4, 5 ]\\n```\\n\\nAll values in an array must be of the same type. You cannot have an array of `String` _and_ `Int`, for instance.\\n\\n#### Records\\n\\nYou can also group different types of named values in a record.\\n\\n```\\ntwoSugars =\\n  { ingredient = \\\"Sugar cube\\\"\\n  , quantity = 2\\n  }\\n\\ncupOfCoffee =\\n  { ingredient = \\\"Cup of coffee\\\"\\n  , quantity = 1\\n  }\\n\\nsweetCoffeeCup : Array { ingredient : String, quantity : Int }\\nsweetCoffeeCup =\\n  [ cupOfCoffee, twoSugars ]\\n```\\n\\nAn interesting thing to note is that record types follow the shape of a record. Two records with the same names with the same associated types, are equal, even when defined in different modules.\\n\\nThe types can become rather painful to write, though, so Gren also supports type aliasing.\\n\\n```\\ntype alias QuantifiedIngredient =\\n  { ingredient : String\\n  , quantity : Int\\n  }\\n\\nsweetCoffeeCup : Array QuantifiedIngredient\\nsweetCoffeeCup =\\n  [ cupOfCoffee, twoSugars ]\\n```\\n\\nIt can be useful to create a record which contains mostly the same values as some other record, but with a few modifications. Gren supports this through special syntax:\\n\\n```gren\\nfourSugars =\\n  { twoSugars\\n    | quantity = 4\\n  }\\n```\\n\\nThe above example creates a new record, called `fourSugars`, which contains the same values as `twoSugars`, except that the `quantity` property has a value of `4` instead of `2`.\\n\\n#### Custom Types\\n\\nSometimes it's helpful with values that can be in one of several states. This can be useful to represent values that may be absent, or operations which can succeed and fail, or cases where you'd typically use enums in other languages.\\n\\nIn Gren, this concept is known as custom types.\\n\\n```gren\\ntype Maybe a\\n    = Just a\\n    | Nothing\\n```\\n\\nThe type `Maybe` can be one of two things. Either it's `Just a` where `a` is a generic type, or it's `Nothing` in which case there is no associated data attached.\\n\\nOn its own, custom types arent very helpful, but in combination with pattern matching they allow for some pretty interesting possibilities.\\n\\n#### Pattern matching\\n\\nWhen dealing with custom types, you likely want to do different things based on the actual value of the custom type. The `case of` expression provides this flexibility.\\n\\n```gren\\nexplainHeldItem : Maybe String -> String\\nexplainHeldItem maybeItem =\\n    case maybeItem of\\n        Nothing ->\\n          \\\"You're not holding anything\\\"\\n\\n        Just item ->\\n          \\\"You're holding a \\\" ++ item\\n\\n\\nholdingSword : String\\nholdingSword =\\n    explainHeldItem (Just \\\"Sword\\\")\\n```\\n\\nYou can use pattern matching on other things than just custom types. Like integers:\\n\\n```gren\\nisZero : Int -> Bool\\nisZero num =\\n    case num of\\n        0 -> True\\n        _ -> False\\n```\\n\\nOr even records:\\n\\n```gren\\ncombineIngredients : QuantifiedIngredient -> QuantifiedIngredient -> QuantifiedIngredient\\ncombineIngredients left right =\\n    case { leftQty = left.quantity, rightQty = right.quantity } of\\n        { leftQty = 0 } ->\\n            right\\n        \\n        { rightQty = 0 } ->\\n            left\\n        \\n        _ ->\\n            { ingredient = left.ingredient ++ \\\" and \\\" ++ right.ingredient\\n            , quantity = left.quantity + right.quantity\\n            }\\n```\\n\"}"},"path":"learn/03_basic_syntax"}